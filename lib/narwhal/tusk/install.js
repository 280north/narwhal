
var tusk = require("../tusk");
var util = require("util");
var args = require("args");
var fs = require("file");
var json = require("json");
var http = require("http");
var zip = require("zip");
var md5 = require("md5");
var packages = require("packages");

var parser = exports.parser = new args.Parser();

parser.help('downloads and installs a package and its dependencies');

parser.args('package');

/*
parser.option('-f', '--force', 'force')
    .bool()
    .help('causes packages to be installed in the project packages directory regardless of whether they are installed elsewhere');

parser.option('-l', '--lean', 'lean')
    .bool()
    .help('causes only the essential components of the library to be installed.');

parser.option('-t', '--test', 'test')
    .bool()
    .help('run tests before installing');

parser.option('-d', '--doc', 'doc')
    .bool()
    .help('build documentation');
*/

parser.option('-s', '--symlink', 'symlink')
    .bool()
    .help('use symbolic links instead of copy to install file:// based packages.');

parser.helpful();

parser.action(function (options) {
    exports.install.call(this, options, options.args);
});

exports.install = function (options, names) {

    if (!tusk.getCatalogPath().isFile()) {
        if (options.simulate) {
            this.print("Run 'tusk update' or 'tusk create-catalog' to get a catalog.");
            return;
        }
        tusk.update.call(this, options);
    }

    var parser = this;
    var catalog = tusk.readCatalog();
    
    // read local catalog
    var localCatalogPath = tusk.getLocalCatalogPath();
    if (localCatalogPath.exists()) {
        var localCatalog = tusk.readCatalog(localCatalogPath);
        for( var name in localCatalog.packages) {
            catalog.packages[name] = localCatalog.packages[name];
        }
    }

    // download a catalog if the current catalog
    //  does not have a version label.
    if (!catalog.version) {
        this.print("Run 'tusk update' or 'tusk create-catalog' to get a catalog.");
        this.print("Your catalog version is no longer supported.");
        return;
    }

    var zipsDirectory = tusk.getZipsDirectory();
    zipsDirectory.mkdirs();

    var namesMap = {};

    // validate the requested names against those
    //  in the catalog of downloadable packages.
    var names = names.filter(function (name) {
        if (!util.has(catalog.packages, name)) {

            // check if name is a file or URL, if it is download it and update the local catalog
            var info = null;
            if(name.substr(0,7)=="file://") {
                info = {protocol: 'file', uri: name.substr(7)}
            } else
            if(name.substr(0,7)=="http://") {
                info = {protocol: 'http', uri: name}
            }
            
            if(info!=null) {
                
                var localCatalogPath = tusk.getLocalCatalogPath();

                // write an empty local catalog
                if (!localCatalogPath.exists()) {
                    tusk.writeCatalog({
                        "!": "This file is generated by 'tusk install [file://|http://]*' and used to track arbitrary packages by URL.",
                        "version": 1,
                        "packages": {},
                        "uris": {}
                    }, localCatalogPath);
                }

                var localCatalog = tusk.readCatalog(localCatalogPath);

                // if package is not in local catalog we add it                
                if (!util.has(localCatalog.uris, name)) {
                    var manifest = null;
                    var uri = info.uri;
                    var onManifestRead = null;
                    switch(info.protocol) {
                        case "http":
                            print('Downloading: ' + uri);
                            var tmpZipFile = zipsDirectory.join(".tmp_" + md5.hash(uri) + ".zip~");
                            var zipData = http.read(uri, 'b');
                            tmpZipFile.write(zipData, 'b');
                            uri = tmpZipFile;
                            
                            // continue with "file" now that we have the archive downloaded
                            
                            onManifestRead = function(manifest)
                            {
                                manifest.location = info.uri;
                                fs.rename(tmpZipFile, zipsDirectory.join(manifest.name + ".zip"));
                            }

                        case "file":
                            var path = fs.path(uri);
                            if(!path.exists()) {
                                print('Could not locate package at: ' + path);
                                return false;
                            }
                            if(path.isDirectory()) {
                                manifest = json.decode(path.join('package.json').read({charset: 'utf-8'}));
                                manifest.type = "directory";
                                manifest.location = info.protocol + "://" + uri;
                            } else {
                                var zipFile = new zip.Unzip(path);
                                // determine first level directory
                                var prefix = null;
                                zipFile.forEach(function (entry) {
                                    if (entry.isDirectory()) {
                                        prefix = fs.split(entry.getName()).shift();
                                        return false;
                                    }
                                });
                                var manifestEntry = zipFile.getEntry(prefix + "/package.json");
                                if(!manifestEntry) {
                                    print("Could not locate package manifest at '/" + prefix + "/package.json' in: " + path);
                                    return false;
                                }
                                manifest = json.decode(manifestEntry.read('b').decodeToString('utf-8'));
                                manifest.type = "zip";
                                manifest.location = info.protocol + "://" + info.uri;
                            }
                            break;
                    }

                    if(onManifestRead!=null) {
                        onManifestRead(manifest);
                    }
                    
                    localCatalog.packages[manifest.name] = manifest;
                    localCatalog.uris[name] = manifest.name;

                    namesMap[name] = manifest.name;

                    tusk.writeCatalog(localCatalog, localCatalogPath);
                } else {
                    namesMap[name] = localCatalog.uris[name];
                }
                
                // merge local catalog packages into our catalog object
                for( var name in localCatalog.packages) {
                    catalog.packages[name] = localCatalog.packages[name];
                }
                
            } else {
                parser.print("ERROR: Package not found: " + util.enquote(name));
                return false;
            }
        }
        return true;
    });
    
    // set names of packages identified by URI
    if(namesMap) {
        for( var i in names ) {
            if(namesMap[names[i]]) {
                names[i] = namesMap[names[i]];
            }
        }
    }

    // load the notes on user-requested and dependency packages
    //  for book keeping.
    var notes = tusk.readNotes();
    names.forEach(function (name) {
        if (!notes[name]) {
            notes[name] = {};
        }
        notes[name].requester = "user";
    });
    tusk.writeNotes(notes);

    // note broken dependency chains
    var errors = [];
    var dependencies = exports.dependencies(catalog.packages, names, errors);
    if (errors.length) {
        print('The following dependencies could not be found in the catalog:');
        printUl(errors.map(function (ancestry) {
            return ancestry.join(' <- ');
        }));
        print('Please notify the package system maintainers.');
        this.exit();
    }

    // notify of packages already installed
    var already = exports.already(packages.catalog, names);
    if (already.length) {
        print('The following packages are already installed:');
        printUl(already);
    }

    // note missing packages
    var missing = exports.missing(packages.catalog, dependencies);
    if (!missing.length) {
        print('No new packages to install.');
        this.exit();
    }
    print('The following packages will be downloaded and installed:');
    printUl(missing);

    // download missing packages and locate local packages
    missing.forEach(function (name) {
        var info = catalog.packages[name];
        if(info.location.substr(0,7)=="http://") {
            print('Downloading: ' + info.location);
            if (options.simulate) 
                return;
            var zipFile = zipsDirectory.join(name + '.zip')
            if (options.resume && zipFile.isFile())
                return;
            var zipData = http.read(info.location, 'b');
            zipFile.write(zipData, 'b');
        } else
        if(info.location.substr(0,7)=="file://") {
            if(info.type=="directory") {
                print('Locating: ' + info.location);
                if(!fs.exists(info.location.substr(7))) {
                    print('Could not locate package!');
                    this.exit();
                }
            } else {
                print('Copying: ' + info.location);
                fs.copy(info.location.substr(7), zipsDirectory.join(name + '.zip'));
            }
        } else {
            throw new Error("location protocol not supported: " + info.location);
        }
    });

    // install missing packages
    missing.forEach(function (name) {
        if (!notes[name])
            notes[name] = {}
        if (!notes[name].files)
            notes[name].files = [];
        if (!notes[name].requester)
            notes[name].requester = "module";
        try {
            
            var targetPath = tusk.getDirectory().join('packages', name);
            
            switch(catalog.packages[name].type) {
                
                case "directory":
                    if(options.symlink) {
                        print('Linking: ' + catalog.packages[name].location.substr(7));
                        fs.symlink(catalog.packages[name].location.substr(7), targetPath);
                    } else {
                        print('Copying: ' + catalog.packages[name].location.substr(7));
                        fs.copyTree(catalog.packages[name].location.substr(7), targetPath);
                    }
                    break;
                    
                case "zip":
                    var zipFile = zipsDirectory.join(name + '.zip')
                    print('Unzipping: ' + zipFile);
                    if (options.simulate)
                        return;

                    // unzip
                    new zip.Unzip(zipFile).forEach(function (entry) {
                        if (entry.isDirectory())
                            return;
                        var parts = fs.split(entry.getName());
                        parts.shift(); // name-project-comment ref dirname
                        var path = targetPath.join(fs.join.apply(null, parts));
                        path.dirname().mkdirs();
                        notes[name].files.push(path);
                        print(path);
                        path.write(entry.read('b'), 'b');
                    });
                    break;
            }

            // write package.json if it was not in the
            // archive
            var packageJson = targetPath.join('package.json');
            if (!packageJson.isFile())
                packageJson.write(
                    json.encode(catalog.packages[name], null, 4),
                    {'charset': 'UTF-8'}
                );

            // make bins executable and make symlinks
            //  in $SEA/bin
            var bin = targetPath.join('bin');
            if (bin.isDirectory())
                bin.list().forEach(function (name) {
                    var target = targetPath.join('bin', name);
                    target.chmod(0755);
                    var sea = tusk.getDirectory().join('bin');
                    var source = sea.join(name);
                    var relative = sea.to(target);
                    if (!source.linkExists()) {
                        target.symlink(source);
                    }
                });

            notes[name].finished = true;
        } catch (exception) {
            var packageJsonPath = tusk.getDirectory().join('packages', name, 'package.json');
            if (packageJsonPath.isFile())
                packageJsonPath.remove();
            throw exception;
        } finally {
            tusk.writeNotes(notes);
            /*
            if (zipFile.isFile())
                zipFile.remove();
            */
        }
    });

    print('Done.');

};

function printUl(lines) {
    lines.forEach(function (line) {
        print(' * ' + line);
    });
};

exports.dependencies = function (catalog, names, errors) {
    var dependencies = {};
    names.forEach(function (name) {
        scan(catalog, dependencies, name, [], errors);
    });
    return Object.keys(dependencies);
};

var scan = function (catalog, dependencies, name, ancestry, errors) {
    if (util.has(dependencies, name))
        return;
    ancestry = [name].concat(ancestry);
    if (!util.has(catalog, name)) {
        errors.push(ancestry);
        return;
    }
    dependencies[name] = true;
    (catalog[name].dependencies || []).forEach(function (child) {
        scan(catalog, dependencies, child, ancestry, errors);
    });
};

exports.already = function (catalog, names) {
    return names.filter(function (packageName) {
        return util.has(catalog, packageName);
    });
};

exports.missing = function (catalog, names) {
    return names.filter(function (packageName) {
        return !util.has(catalog, packageName);
    });
};

